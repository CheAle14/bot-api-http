<!DOCTYPE html>
<html>
    <head>
        <title>Newer recipe ongoing system</title>
    </head>
    <body>
        <pre><code id="output">Output will appear here.</code></pre>
        <br/>
        <div id="table">
        </div>
        <script>
            const outEl = document.getElementById("output");
            function output(str) {
                outEl.innerText = str;
            }
            function getNow() {
                return Math.floor(Date.now() / 1000);
            }

            class RecipeTable {
                constructor() {
                    this.table = document.createElement("table");
                    document.getElementById("table").appendChild(this.table);

                    this.rows = [];
                    this.headers = [];
                    this.withHeader("[Time]", -1);
                }
                getCell(colx, rowy, type = "td") {
                    while(this.rows.length <= rowy) {
                        var r = this.table.insertRow();
                        r.setAttribute("data-args", `(${colx}, ${rowy})`);
                        this.rows.push(r);
                    }
                    var row = this.rows[rowy];
                    while(row.children.length <= colx) {
                        var tc = row.insertCell();
                    }
                    return row.children[colx];
                }
                getRowForTime(now_ts, time) {
                    var search = `${Math.round(time)}`;
                    var human = `${Math.round(time - now_ts)}`;
                    for(var idx = 1; idx < this.rows.length; idx++) {
                        var here = this.getCell(0, idx, "th");
                        const hereTime = here.getAttribute("data-time");
                        console.log(idx, hereTime);
                        if(!hereTime) {
                            here.innerText = human;
                            here.setAttribute("data-time") = search;
                            here.setAttribute("data-line", "54");
                            console.log("Found: empty row");
                            return idx;
                        }
                        if(hereTime == search) return idx;
                        var num = parseInt(hereTime);
                        if(num > time) {
                            var inserted = this.table.insertRow(idx);
                            this.rows.splice(idx, 0, inserted);
                            var c = this.getCell(0, idx, "th");
                            c.innerText = human
                            c.setAttribute("data-line", "65");
                            c.setAttribute("data-time", search);
                            console.log("Inserting inbetween");
                            return idx;
                        }
                    }
                    console.log("Adding new row at", idx);
                    var cell = this.getCell(0, idx, "th");
                    cell.innerText = human;
                    cell.setAttribute("data-time", search);
                    cell.setAttribute("data-line", "73");
                    return idx;
                }
                removeRowsAfter(idx) {
                    while(this.rows.length > idx) {
                        console.log("REM", this.rows.length, idx);
                        this.table.deleteRow(-1)
                        this.rows.pop();
                    }
                }
                withHeader(text, idx) {
                    this.getCell(idx+1, 0, "th").innerText = text;
                    this.headers.splice(idx+1, 0, text);
                }

                setTimes(now_ts, sortedSteps) {
                    var rowIdx = 1;
                    var lastTime = 0;
                    console.log("TIMES:", this);
                    console.log("STEPS:", sortedSteps);
                    const updates = {};
                    for(var idx = 0; idx < sortedSteps.length; idx++) {
                        const step = sortedSteps[idx];
                        const group = groupFunc(step.recipe);
                        console.group(step.text);
                        const colIdx = this.headers.indexOf(group);
                        const rowIdx = this.getRowForTime(now_ts, step.estimatedStartAt);
                        console.log("cds:", colIdx, rowIdx);
                        var cell = this.getCell(colIdx, rowIdx, "td");
                        cell.setAttribute("data-fresh", "true");
                        if(step.state === STATE.COMPLETE) {
                            cell.innerHTML = `<del>${step.text}</del>`
                        } else {
                            cell.innerHTML = `${step.text} ${step.estimatedStartAt}`;
                        }
                        console.groupEnd();
                    }
                    var toremove = [];
                    for(let rdx = 1; rdx < this.rows.length; rdx++) {
                        var any = false;
                        for(let cdx = 1; cdx < this.headers.length; cdx++) {
                            var cell = this.getCell(cdx, rdx, "td");
                            const update = cell.hasAttribute("data-fresh");
                            if(update) {
                                any = true;
                            } else {
                                cell.innerHTML = "";
                            }
                        }
                        if(!any) {
                            toremove.push(rdx);
                        }
                    }
                    for(let index of toremove) {
                        this.table.deleteRow(index);
                        this.rows.splice(index, 1);
                    }
                }
            }

            const TABLE = new RecipeTable();

            const STATE = {
                PENDING: "pending",
                ONGOING: "ongoing",
                COMPLETE: "complete"
            }
            class RecipeStep {
                constructor(text, duration = 0, delay = 0) {
                    this.text = text;
                    this.duration = duration;
                    this.remaining = duration;
                    this.delay = delay;

                    this.recipe = null;
                    this.state = STATE.PENDING;
                    this.startedAt = null;
                    this.estimatedStartAt = null;
                    this.finishedAt = null;
                }

                tick(elapsed) {
                    this.remaining -= elapsed;
                }
            }

            class Recipe {
                constructor(name, catalyst) {
                    this.name = name;
                    this.catalyst = catalyst;
                    this.steps = [];

                    this.startedAt = null;
                    this.finishedAt = null;
                    this.cachedTotalDuration = null;
                }
                withStep(...args) {
                    var step =  new RecipeStep(...args);
                    step.recipe = this;
                    this.steps.push(step);
                    
                    return this;
                }

                getDisplayInfo(now_ts) {
                    if(this.finishedAt) {
                        var timeToComplete = this.finishedAt - this.startedAt;
                        var diff = timeToComplete - this.cachedTotalDuration;
                        return {text: `${diff}`, time: 0}
                    }
                    if(this.startedAt === null) {
                        var timeUntilStart = this.steps[0].estimatedStartAt - now_ts;
                        return {text: this.steps[0].text, time: timeUntilStart};
                    }
                    for(var index = 0; index < this.steps.length; index++) {
                        const step = this.steps[index];
                        if(step.state === STATE.COMPLETE) continue;
                        
                        if((index + 1) < this.steps.length) {
                            const next = this.steps[index + 1];
                            var diff = next.estimatedStartAt - now_ts;
                            return {
                                text: next.text,
                                time: diff - step.delay
                            };
                        }
                        return {
                            text: "??Dish up??",
                            time: step.remaining
                        };
                    }
                    return {
                        text: "!error!",
                        time: -1
                    };
                }

                getTotalTime() {
                    var sumremain = 0;
                    var overruns = 0;
                    for(let step of this.steps) {
                        if(step.state === STATE.COMPLETE) continue;

                        if(step.remaining < (step.delay * -1)) {
                            overruns += (step.delay * -1) - step.remaining;
                        } else {
                            sumremain += step.remaining + step.delay
                        }
                    }
                    if(this.cachedTotalDuration === null) {
                        this.cachedTotalDuration = sumremain;
                    }
                    return sumremain; // + overruns;
                }
                getEstimatedEnd(now_ts) {
                    return now_ts + this.getTotalTime();
                }
                _setStartTimesFromStart(now_ts) {
                    var remaining = 0;
                    for(var index = 0; index < this.steps.length; index++) {
                        const step = this.steps[index];
                        if(step.state === STATE.COMPLETE) continue;
                        if(step.state === STATE.ONGOING) {
                            if((index + 1) < this.steps.length) {
                                const next = this.steps[index+1];
                                remaining += step.remaining + step.delay;
                                next.estimatedStartAt = now_ts + remaining;
                            }
                        }
                    }
                }
                _setStartTimesByEnd(target_end) {
                    var duration = 0;
                    for(let index = this.steps.length - 1; index >= 0; index--) {
                        const step = this.steps[index];

                        duration += step.duration;
                        if((index - 1 >= 0)) {
                            const prev = this.steps[index-1];
                            duration += prev.delay;
                        }
                        step.estimatedStartAt = target_end - duration;
                    }
                }
                setEstimatedStartTimes(now_ts, target_end) {
                    if(this.startedAt) this._setStartTimesFromStart(now_ts);
                    else this._setStartTimesByEnd(target_end);
                }

                advance() {
                    for(var index = 0; index < this.steps.length; index++) {
                        const step = this.steps[index];
                        if(step.state === STATE.COMPLETE) continue;
                        if(step.state === STATE.PENDING) {
                            step.recipe.startedAt = getNow();
                            step.state = STATE.ONGOING;
                            step.startedAt = this.startedAt;
                            break;
                        } else if(step.state === STATE.ONGOING) {
                            step.state = STATE.COMPLETE;
                            var now = getNow();
                            step.finishedAt = now;
                            if((index + 1) < this.steps.length) {
                                const next = this.steps[index+1];
                                next.state = STATE.ONGOING;
                                next.startedAt = now;
                                if(next.duration > 0) break;
                            } else {
                                console.log("Completed", this.name)
                                step.recipe.finishedAt = now;
                            }
                        }
                    }
                }

                tick(elapsed) {
                    for(var step of this.steps) {
                        if(step.state === STATE.ONGOING) 
                            step.tick(elapsed);
                    }
                }
            }

            class GroupedRecipes extends Recipe {
                constructor(key, recipes) {
                    super(key, key);
                    this.recipes = recipes;
                    for(let recipe of this.recipes){
                        for(let step of recipe.steps)
                            this.steps.push(step);                      
                    }
                    this.sort();
                }

                get startedAt() {
                    for(let recipe of this.recipes) {
                        if(recipe.startedAt) {
                            return recipe.startedAt;
                        }
                    }
                    return null;
                }
                set startedAt(v) {}
                get finishedAt() {
                    var f = null;
                    for(let recipe of this.recipes) {
                        if(recipe.finishedAt == null) return null;
                        if(f == null || recipe.finishedAt > f)
                            f = recipe.finishedAt;
                    }
                    return f;
                }
                set finishedAt(v) {}

                sort() {
                    this.steps.sort((a, b) => a.estimatedStartAt < b.estimatedStartAt);
                }

                getTotalTime() {
                    var longest = null;
                    for(let recipe of this.recipes) {
                        var t = recipe.getTotalTime();
                        if(longest == null || longest < t) {
                            longest = t;
                        }
                    }
                    return longest;
                }

                advance() {
                    super.advance();
                }
            }

            var bakedBeans = new Recipe("Baked Beans", "microwave")
                .withStep("Put beans in", 15, 0)
                .withStep("Stir beans", 15, 0)
                .withStep("Stir beans", 15, 0)
                .withStep("Dish beans", 0, 0)
            
            var toast = new Recipe("Toast", "toaster")
                .withStep("Put toast in", 15, 0)
                .withStep("Dish toast");

            var sausages = new Recipe("Sausages", "oven")
                .withStep("Put sausages in", 20, 0)
                .withStep("Turn sausages over", 20, 0)
                .withStep("Dish sausages", 0, 0)

            const RECIPES = [bakedBeans, toast, sausages];

            var groupByCatalyst = (r) => r.catalyst;
            var groupCustom = (r) => {
                if(r == toast || r == bakedBeans) return "First";
                return "Second";
            };
            var noGroup = (r) => r.name;
            var groupFunc = noGroup;

            function getGroupedRecipes() {
                var grouped = {};
                for(let recipe of RECIPES) {
                    var key = groupFunc(recipe);
                    var array = grouped[key];
                    if(array) {
                        array.push(recipe);
                    } else {
                        array = [recipe];
                        grouped[key] = array;
                    }
                }
                var recipes = [];
                var idx = 0;
                for(let key in grouped) {
                    var proxyRecipe = new GroupedRecipes(key, grouped[key]);
                    recipes.push(proxyRecipe);
                    TABLE.withHeader(key, idx++);
                }
                return recipes;
            }

            const GROUPED = getGroupedRecipes()
            console.log("Groups:", GROUPED);

            var lastTick = null;
            var updateTable = true;
            function globalTick(diff) {
                var nowTick = window.performance.now();
                var diff = (nowTick - (lastTick ?? nowTick)) / 1000;
                lastTick = nowTick;
                for(let recipe of RECIPES)
                    recipe.tick(diff);

                var now = getNow();
                setStartTimes(now);
                setDisplay(now);
                if(updateTable) {
                    updateTable = false;
                    var allSteps = [];
                    for(let recipe of RECIPES) {
                        for(let step of recipe.steps)
                            allSteps.push(step);
                    }
                    allSteps.sort((a, b) => a.estimatedStartAt < b.estimatedStartAt);
                    TABLE.setTimes(now, allSteps);
                }
            }

            function all(array, predicate) {
                for(let o of array) {
                    if(!predicate(o)) return false;
                }
                return true;
            }

            function setDisplay(now) {
                now = now ?? getNow();
                var s = [];

                for(let recipe of GROUPED) {
                    var info = recipe.getDisplayInfo(now);
                    s.push(`${recipe.name}: ${info.text} in ${info.time}`);
                }

                output(s.join("\n"))
            }

            function setStartTimes(now) {
                now = now ?? getNow();
                var furthestEnd = null;
                for(let recipe of GROUPED) {
                    var end = recipe.getEstimatedEnd(now);
                    if(furthestEnd === null || end > furthestEnd) {
                        furthestEnd = end;
                    }
                }
                for(let recipe of GROUPED) {
                    recipe.setEstimatedStartTimes(now, furthestEnd);
                }
            }

            function doAdvance(recipe) {
                recipe.advance();
                setStartTimes();
            }

            globalTick();
        </script>
    </body>
</html>