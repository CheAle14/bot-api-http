<!DOCTYPE html>
<html>
    <head>
        <title>Recipe</title>
        <style>
            #container {
                display: flex;
            }
            .group {
                border: 1px solid black;
                padding-left: 5px;
            }
            .complete {
                background-color: greenyellow;
            }
            .alarm {
                background-color: red;
            }
            .notice {
                background-color: orange;
            }
            .selected {
                border: 5px solid blue;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                border: 1px solid #ddd;
                font-size: 18px;
            }

            th, td {
                text-align: left;
                padding: 12px;
            }

            tr {
                border-bottom: 1px solid #ddd;
            }
        </style>
    </head>
    <body>
        <div id="container">
        </div>
        <div id="tableContainer">
        </div>
        <div>
            <h2>Time since start</h2>
            <h1 id="startTimer"></h1>
        </div>

        <script>
            function orderedInsert(array, element, isBefore) {
                var ind = 0;
                for(let other of array) {
                    if(isBefore(other, element) ) {
                        ind += 1;
                    } else {
                        break;
                    }
                }
                array.splice(ind, 0, element);
                return array;
            }
            function pad(str, nfill, chr = '0') {
                str = `${str}`;
                if(str.length > nfill) {
                    return str;
                } else {
                    return (chr.repeat(nfill - str.length)) + str;
                }
            }
            function formatTimer(seconds) {
                if(seconds < 0) {
                    return "-" + formatTimer(seconds * -1);
                }
                var hours = Math.floor(seconds / 3600);
                if(hours > 0) {
                    seconds -= (hours * 3600);
                }
                var minutes = Math.floor(seconds / 60);
                if(minutes > 0) {
                    seconds -= (minutes * 60);
                }
                seconds = Math.round(seconds);
                return pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2);
            }
            const STATE = {
                PENDING: "pending",
                ONGOING: "ongoing",
                COMPLETE: "complete"
            };
            class Step {
                constructor(text, originalDuration) {
                    this.text = text;
                    this.duration = originalDuration;
                    this.remaining = originalDuration;
                    this.state = STATE.PENDING;

                    this.startedAt = null;
                    this.tentativeStartTime = null;
                }

                tick(elapsed) {
                    this.remaining -= elapsed;
                }
            }
            class Recipe {
                constructor(catalyst) {
                    this.steps = [];
                    this.current = 0;
                    this.catalyst = catalyst;
                }
                get workingOn() {
                    if(this.current >= this.steps.length) return null;
                    return this.steps[this.current];
                }
                get nextUp() {
                    var n = this.current + 1;
                    if(n >= this.steps.length) return null;
                    return this.steps[n];
                }

                withStep(text, duration) {
                    var s = new Step(text, duration || 0);
                    this.steps.push(s);
                    return this;
                }

                _sumLength(original) {
                    var sum = 0;
                    for(let step of this.steps) {
                        if(original) {
                            sum += step.duration;
                        } else {
                            sum += step.remaining;
                        }
                    }
                    return sum;
                }

                sumOriginalLength() {
                    return this._sumLength(true);
                }
                sumRemainLength() {
                    return this._sumLength(false);
                }
            }

            function getOrCreate(id, tag, parent) {
                var d = document.getElementById(id);
                if(d) return d;
                d = document.createElement(tag);
                d.id = id;
                parent.appendChild(d);
                return d;
            }

            class RecipeGroup {
                constructor(initRecipe) {
                    this.catalyst = initRecipe.catalyst;
                    this.recipes = [initRecipe];
                    this.simpleSteps = [];
                    this.delayTime = null;
                    
                    this.muted = null;
                    this.alarm = false;
                    this.completedAt = null;
                }

                tick(elapsed) {
                    for(let step of this.simpleSteps) {
                        if(step.state === STATE.ONGOING)
                            step.tick(elapsed);
                    }
                }

                _sumLength(original) {
                    var longest = 0;
                    for(let recipe of this.recipes) {
                        var length;
                        if(original) {
                            length = recipe.sumOriginalLength();
                        } else {
                            length = recipe.sumRemainLength();
                        }
                        if(length > longest) {
                            longest = length;
                        }
                    }
                    return longest;
                }
                sumOriginalLength() {
                    return this._sumLength(true);
                }
                sumRemainLength() {
                    return this._sumLength(false);
                }
                flattenForEnd(targetEnd) {
                    // e.g. target end is 200 seconds.
                    // recipe 
                    var simpleSteps = [];
                    var lastTime = null;
                    for(let recipe of this.recipes) {
                        var recipeDelay = targetEnd - recipe.sumRemainLength();
                        for(let step of recipe.steps) {
                            step.tentativeStartTime = recipeDelay;
                            simpleSteps = orderedInsert(simpleSteps, step, (other, inserting) => other.tentativeStartTime < inserting.tentativeStartTime);
                            if(step.state != STATE.COMPLETE) {
                                recipeDelay += step.remaining;
                            }
                            lastTime = step.tentativeStartTime + step.remaining;
                        }
                    }

                    this.simpleSteps = simpleSteps;
                    const end = this.simpleSteps.length - 1;
                    if(this.simpleSteps[end].duration > 0) {
                        var dishStep = new Step("Dish up", 0);
                        dishStep.tentativeStartTime = lastTime || 0;
                        this.simpleSteps.splice(end + 1, 0, dishStep);
                    }
                    this.delayTime = this.simpleSteps[0].tentativeStartTime;

                    // go through and correct durations
                    var nextStart  = null;
                    for(let index = this.simpleSteps.length - 1; index >= 0; index--) {
                        const step = this.simpleSteps[index];
                        if(nextStart) {
                            step.duration = nextStart - step.tentativeStartTime;
                            step.remaining = step.duration;
                        }
                        nextStart = step.tentativeStartTime;
                    }
                }
                withRecipe(recipe) {
                    this.recipes.push(recipe);
                }

                getDisplayText() {
                    var shownText = null;
                    var shownTime = null;
                    for(let index = 0; index < this.simpleSteps.length; index++) {
                        const step = this.simpleSteps[index];
                        if(step.state === STATE.COMPLETE) {
                            continue;
                        }
                        else if(step.state === STATE.ONGOING) {
                            var next = this.simpleSteps[index + 1];
                            if(next)
                                shownText = next.text;
                            else 
                                shownText = "Dish up";
                            shownTime = step.remaining;
                            break;
                        }
                        else if(step.state === STATE.PENDING) {
                            shownText = step.text;
                            if(startedAt) {
                                var diff = (Date.now() - startedAt) / 1000;
                                shownTime = step.tentativeStartTime - diff;
                            } else {
                                shownTime = step.tentativeStartTime;
                            }
                            break;
                        }
                    }
                    if(shownText === null) {
                        // all complete
                        shownText = "Complete";
                        shownTime = 0;
                        if(this.completedAt == null) {
                            this.completedAt = Date.now();
                        }
                    }
                    if(this.muted) {
                        shownText = "(M) " + shownText;
                    }
                    return {
                        text: shownText,
                        time: shownTime
                    };
                }

                toHTML(isSelected, parent) {
                    const CAT = this.catalyst.replace(' ', '-');
                    const ID = `timer-${CAT}`;                    
                    const DATA = this.getDisplayText();
                    const shownText = DATA.text;
                    const shownTime = DATA.time;
                    var mainDiv = getOrCreate(ID, "div", parent);
                    mainDiv.classList.add("group");
                    mainDiv.classList.add(CAT);
                    const _this = this;

                    mainDiv.onclick = function() {
                        if(_this.muted) {
                            _this.onAdvance();
                        } else {
                            _this.onMute();
                        }
                    };
                    if(isSelected) {
                        mainDiv.classList.add("selected");
                    } else {
                        mainDiv.classList.remove("selected");
                    }
                    var text = getOrCreate(ID + "-text", "h2", mainDiv);
                    text.innerText = shownText;
                    var timer = getOrCreate(ID + "-time", "h1", mainDiv);
                    if(this.completedAt) {
                        mainDiv.classList.add("complete");
                        mainDiv.classList.remove("alarm", "notice");
                        var diffS = (this.completedAt - this.startedAt) / 1000;
                        var targetS = this.sumOriginalLength();
                        var diffFromTarget = diffS - targetS;
                        if(diffFromTarget > 0) {
                            timer.innerText = "over +" + formatTimer(diffS - targetS) + "+";
                        } else {
                            timer.innerText = "under " + formatTimer(diffS - targetS) + "-";
                        }
                    } else {
                        mainDiv.classList.remove("complete");
                        if(shownTime < 3) {
                            mainDiv.classList.add("alarm");
                            mainDiv.classList.remove("notice");
                            this.alarm = true;
                            if(this.muted === null) {
                                this.muted = false;
                            }
                            checkAudio();
                        } else if (shownTime < 30) {
                            mainDiv.classList.remove("alarm");
                            mainDiv.classList.add("notice");
                        } else {
                            mainDiv.classList.remove("alarm", "notice");
                        }
                        timer.innerText = formatTimer(shownTime);
                    }
                    return mainDiv;
                }

                onMute() {
                    const data = this.getDisplayText();
                    console.log("Try", this.catalyst, data);
                    if(data.time <= 3) {
                        this.muted = true;
                    }
                }
                onAdvance() {
                    console.log("Advance", this.catalyst);
                    this.muted = null;
                    this.alarm = false;
                    refreshTableNextTick = true;

                    if(startedAt === null) {
                        startedAt = Date.now();
                    }

                    for(let index = 0; index < this.simpleSteps.length; index++) {
                        const step = this.simpleSteps[index];
                        if(step.state === STATE.COMPLETE) continue;
                        if(step.state === STATE.PENDING) {
                            step.state = STATE.ONGOING;
                            this.startedAt = startedAt;
                            console.log("Started with", step.text, ", next up is", this.simpleSteps[index + 1]);
                            break;
                        }
                        if(step.state === STATE.ONGOING) {
                            step.state = STATE.COMPLETE;
                            var next = this.simpleSteps[index + 1];
                            if(next) {
                                next.state = STATE.ONGOING;
                                console.log("Moving to", next.text, "in", step.duration);

                                if(next.duration > 0) {
                                    break;
                                }
                            } else {
                                console.log("Finished group with final", step.text);
                            }
                        }
                    }
                }
            }

            var beans = new Recipe("microwave")
            .withStep("Put baked beans in", 1.5 * 60)
            .withStep("Stir beans first", 1.5 * 60)
            .withStep("Stir beans second", 1.5 * 60)
            .withStep("Stir beans third", 1.5 * 60);


            var sausages = new Recipe("oven")
            .withStep("Put sausages in", 7.5 * 60)
            .withStep("Flip sausages", 7.5 * 60);

            var toast = new Recipe("toaster")
            .withStep("Put toast on", 160);

            var bacon = new Recipe("frying pan")
            .withStep("Heat frying pan", 120)
            .withStep("Put bacon on pan", 1.5 * 60)
            .withStep("Flip bacon first", 1.5 * 60)
            .withStep("Flip bacon second", 1.5 * 60)
            .withStep("Flip bacon third", 1.5 * 60);

            var ovenBacon = new Recipe("oven")
            .withStep("Put bacon in oven", 10 * 60)
            .withStep("Check bacon", 60)
            .withStep("Check bacon", 60)

            var scrambledEggs = new Recipe("small pan")
            .withStep("Heat pan up", 60)
            .withStep("Begin scrambled eggs", 5 * 60);

            var chips = new Recipe("air fryer")
            .withStep("Put chips in", 8 * 60)
            .withStep("Shake chips and put back on", 8 * 60);

            var burgers = new Recipe("grill")
            .withStep("Put burgers in", 4 * 60)
            .withStep("Flip burgers first", 4 * 60)
            .withStep("Flip burgers second", 4 * 60)
            .withStep("Flip burgers third", 4 * 60)
            .withStep("Flip burgers fourth, apply cheese", 4 * 60);

            var hashbrowns = new Recipe("air fryer")
            .withStep("Put hash browns in", 6 * 60)
            .withStep("Flip hash browns", 6 * 60);


            var recipes = [burgers, ovenBacon, chips];

            var mash = new Recipe("microwave")
            .withStep("Put mash potato in", 3 * 60)
            .withStep("Stir and put back in", 2.5 * 60);

            var yorkshirePuds = new Recipe("oven")
            .withStep("Put yorks in", 3 * 60);

            var gravy = new Recipe("kettle")
            .withStep("Boil water and do gravy", 180);

            var carrotsAndPeas = new Recipe("microwave")
            .withStep("Put carrots+peas in", 3 * 60);

            var pigsBlankets = new Recipe("oven")
            .withStep("Put pigs in blankets in", 25 * 60);

            var stuffing = new Recipe("oven")
            .withStep("Put stuffing in", 18 * 60);

            var lambSteaks = new Recipe("grill")
            .withStep("Put lamb steaks in", 4.5 * 60)
            .withStep("Flip lamb steaks, put back", 4.5 * 60);

            //var recipes = [mash, yorkshirePuds, gravy, carrotsAndPeas, pigsBlankets, stuffing, lambSteaks];




            function groupRecipes(recipes) {
                var groups = {};
                for(let recipe of recipes) {
                    var existing = groups[recipe.catalyst];
                    if(existing) {
                        existing.withRecipe(recipe);
                    } else {
                        groups[recipe.catalyst] = new RecipeGroup(recipe);
                    }
                }
                return groups;
            }

            var startedAt = null;
            var recipeGroups = groupRecipes(recipes);
            var catalystOrder = [];
            var selected = null;
            var lastTick = null;
            var refreshTableNextTick = false;
            var audio = new Audio("../_/assets/alarm.mp3");
            var intervalId = null;

            function checkAudio() {
                if(startedAt == null) {
                    audio.pause();
                    return;
                }
                var anyAlarm = false;
                var allMuted = true;
                for(let catalyst of catalystOrder) {
                    const group = recipeGroups[catalyst];
                    if(group.alarm) {
                        anyAlarm = true;
                        if(!group.muted) {
                            allMuted = false;
                        }
                    }
                }
                if(anyAlarm && !allMuted) {
                    audio.play();
                } else {
                    audio.pause();
                }
            }

            function init(recipeGroups) {
                var longest = 0;
                for(let catalyst in recipeGroups) {
                    catalystOrder.push(catalyst);
                    var group = recipeGroups[catalyst];
                    var length = group.sumRemainLength();
                    if(length > longest) {
                        longest = length;
                    }
                }
                for(let catalyst of catalystOrder) {
                    var group = recipeGroups[catalyst];
                    group.flattenForEnd(longest);
                    if(selected === null && group.delayTime === 0) {
                        selected = catalyst;
                    }
                }
                refreshHtml(true);

                lastTick = window.performance.now() / 1000;
                intervalId = setInterval(globalTick, 50);
            }

            class Row {
                constructor(initStep, catalyst) {
                    this.time = initStep.tentativeStartTime;
                    this.steps = [];
                    for(let other of catalystOrder) {
                        if(other === catalyst) {
                            this.steps.push(initStep);
                        } else {
                            this.steps.push(null);
                        }
                    }
                }
                tryAdd(step, catalystIndex) {
                    var diff = Math.abs(this.time - step.tentativeStartTime);
                    if(diff <= 1) {
                        this.steps[catalystIndex] = step;
                        return true;
                    }
                    return false;
                }
                toHTML() {
                    var tr = document.createElement("tr");

                    var tdTime = document.createElement("td");
                    tdTime.innerText = formatTimer(this.time);
                    tr.appendChild(tdTime);

                    var numNulls = 0;
                    for(let step of this.steps) {
                        if(step === null) {
                            numNulls += 1;
                            continue;
                        }
                        if(numNulls > 0) {
                            var nltd = document.createElement("td");
                            nltd.colSpan = numNulls;
                            tr.appendChild(nltd);
                            numNulls = 0;
                        }
                        var td = document.createElement("td");
                        if(step.state === STATE.PENDING) {
                            td.innerText = step.text;
                        } else {
                            var st = document.createElement("del");
                            st.innerText = step.text;
                            td.appendChild(st);
                        }
                        tr.appendChild(td);
                    }
                    if(numNulls > 0) {
                        var nltd = document.createElement("td");
                        nltd.colSpan = numNulls;
                        tr.appendChild(nltd);
                    }
                    return tr;
                }
            }

            function generateTable() {
                var rows = [];
                var catIndex = 0;
                for(let catalyst of catalystOrder) {
                    const group = recipeGroups[catalyst];
                    for(let step of group.simpleSteps) {
                        var done = false;
                        for(var row of rows) {
                            if(row.tryAdd(step, catIndex)) {
                                done = true;
                                break;
                            }
                        }
                        if(done) continue;

                        var newRow = new Row(step, catalyst);
                        rows = orderedInsert(rows, newRow, (before, next) => before.time < next.time);
                    }
                    catIndex += 1;
                }
                var table = document.createElement("table");
                var headTr = document.createElement("tr");
                var timeTh = document.createElement("th");
                timeTh.innerText = "Time";
                headTr.appendChild(timeTh);
                table.appendChild(headTr);
                for(let catalyst of catalystOrder) {
                    var th = document.createElement("th");
                    th.innerText = catalyst;
                    headTr.appendChild(th);
                }
                for(var row of rows) {
                    table.appendChild(row.toHTML());
                }
                return table;
            }

            function refreshHtml(updateTable) {
                var container = document.getElementById("container");
                var widthPerc = (1 / catalystOrder.length) * 100;
                for(let catalyst of catalystOrder) {
                    const group = recipeGroups[catalyst];
                    var div = group.toHTML(group.catalyst === selected, container);
                    div.style.flex = `${widthPerc}%`;
                }

                if(startedAt) {
                    var startDiff = Math.round((Date.now() - startedAt) / 1000);
                    document.getElementById("startTimer").innerText = formatTimer(startDiff);
                } else {
                    document.getElementById("startTimer").innerText = "n.y.s";
                }

                if(!updateTable) return;
                var table = document.getElementById("tableContainer");
                table.innerHTML = "";
                table.appendChild(generateTable());
                checkAudio();
            }

            init(recipeGroups);


            function globalTick() {
                var nextTick = window.performance.now() / 1000;
                var tickDelta = nextTick - lastTick;
                lastTick = nextTick;

                var allcomplete = true;
                for(let catalyst of catalystOrder) {
                    const group = recipeGroups[catalyst];
                    group.tick(tickDelta);
                    if(group.completedAt == null) {
                        allcomplete = false;
                    }
                }
                if(allcomplete) {
                    console.log("Done!");
                    clearInterval(intervalId);
                    audio.pause();
                }


                refreshHtml(refreshTableNextTick);
                refreshTableNextTick = false;
            }

            document.body.onkeyup = function(event) {
                if(event.key === "Enter") {
                    const group = recipeGroups[selected];
                    if(group) {
                        if(group.muted) {
                            group.onAdvance();
                        } else {
                            group.onMute();
                        }
                    }
                    checkAudio();
                    event.preventDefault();
                    return false;
                } else if(event.key === "Tab" || event.key === "t" || event.key === "T") {
                    var found = false;
                    var curIndex = catalystOrder.indexOf(selected);
                    if(curIndex === -1) curIndex = 0;
                    if(event.shiftKey) {
                        curIndex -= 1;
                    } else {
                        curIndex += 1;
                    }
                    if(curIndex >= catalystOrder.length)
                        curIndex = 0;
                    if(curIndex < 0)
                        curIndex = catalystOrder.length - 1;
                    selected = catalystOrder[curIndex];
                } else if(event.key === "ArrowRight") {
                    var time = 1;
                    if(event.ctrlKey) {
                        time = 10;
                    }
                    if(event.shiftKey) {
                        time *= 6;
                    }
                    console.log("Skipping", time);

                    for(let catalyst of catalystOrder) {
                        const group = recipeGroups[catalyst];
                        group.tick(time);
                    }
                    startedAt -= (time * 1000);
                }
            }
        </script>
    </body>
</html>
