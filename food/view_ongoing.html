<!DOCTYPE html>
<html>
    <head>
        <title>Viewing Ongoing Recipe</title>
        <style>
            html, body, div {
                margin: 0;
                min-height: 100%;
            }
            h1 {
                font-size: 4em;
            }
            h2 {
                font-size: 3em;
            }
            h3 {
                font-size: 2em;
                margin: 0;
            }
            h1, h2, h3, p {
                margin: 0;
                padding: 0;
                text-align: center
            }
            .notify-icon {
                top: 0;
                position: fixed;
            }
        </style>
        <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.1/dist/js.cookie.min.js"></script>
    </head>
    <body>
        <div>
            <img class="notify-icon" id="wsClosed" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/Warning.svg/260px-Warning.svg.png" width="5%" style="display: none">
            <img class="notify-icon" id="sentnext" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/eb/Blue_check.svg/240px-Blue_check.svg.png" width="5%" style="display: none">
            <img class="notify-icon" id="muted" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Mute_Icon.svg/500px-Mute_Icon.svg.png" width="5%" style="display: none">
            <h1 id="desc"></h1>
            <h2 id="time"></h2>
            <h3 id="endsAt"></h3>

            <p><strong id="after"></strong></p>
            <table id="full">

            </table>
            <input type="button" id="editBtn" value="Enable Editing" onclick="enableEdit(this);">
            <input type="checkbox" id="editRemember" onclick="rememberEdit(this)">
        </div>
        <script src="../_/js/bot-ws.js"></script>
        <script>
            const ID = "<REPLACE id='id'/>";
            const descElem = document.getElementById("desc");
            const timeElem = document.getElementById("time");
            const endsAtElem = document.getElementById("endsAt");
            const afterElem = document.getElementById("after");
            const tableElem = document.getElementById("full");
            const editRemember = document.getElementById("editRemember");
            const editBtn = document.getElementById("editBtn");
            const wsNext = document.getElementById("sentnext");


            class NotifyIcons {
                constructor() {
                    this.icons = [];
                }
                add(icon) {
                    this.icons.push(icon);
                }
                refresh() {
                    var left = 0;
                    for(let icon of this.icons) {
                        if(icon.style.display !== "none") {
                            icon.style.left = `${left}%`;
                            left += 6;
                        }
                    }
                }
                update(name, value) {
                    for(let icon of this.icons) {
                        if(icon.id === name) {
                            icon.style.display = value ? "" : "none";
                            break;
                        }
                    }
                    this.refresh();
                }
            }

            const ICONS = new NotifyIcons();
            ICONS.add(document.getElementById("wsClosed"));
            ICONS.add(document.getElementById("sentnext"));
            ICONS.add(document.getElementById("muted"));


            const STATES = {
                NOT_STARTED: "Not Started",
                PREPPING: "Prepping",
                STARTED: "Started",
                FINISHING: "Finishing",
                FINISHED: "Finished"
            }
            class Step {
                constructor(parent, rem, delay) {
                    this._parent = parent;
                    this._remaining = rem;
                    this._duration = rem;
                    this._delay = delay;
                    this._state = STATES.NOT_STARTED;
                }
                tick(delta) {
                    if(this._state !== STATES.STARTED) return;
                    this._remaining -= delta;
                    if(this._remaining <= 0) {
                        this._state = STATES.FINISHING;
                        this._remaining = 0;
                    }
                }

                get state() {
                    return this._state;
                }

                set state(value) {
                    this._state = value;
                    if(this._parent) {
                        this._parent.check_state();
                    }
                }
            }
            class SimpleStep extends Step {
                constructor(parent, text, duration, delay) {
                    super(parent, duration, delay);
                    this._text = text;
                }
            }
            class MultiStep extends Step {
                constructor(parent, text, order) {
                    super(parent, 0, 0);
                    this._text = text;
                    this._children = [];
                    this._inorder = order;
                }
                push(child) {
                    this._children.push(child);
                    if(this._inorder) {
                        this._duration += child._duration;
                        this._delay += child._delay;
                    } else {
                        if(child._duration > this._duration) {
                            this._duration = child._duration;
                            this._delay = child._delay;
                        }
                    }
                    this._remaining = this._duration + this._delay;
                }
                set_remain() {
                    let v = 0;
                    for(let child of this._children) {
                        if(child._remaining > v) {
                            v = child._remaining;
                        }
                    }
                    this._remaining = v;
                }
                tick(delta) {
                    for(let child of this._children) {
                        if(child._state !== STATES.STARTED) continue;
                        child.tick(delta);
                        if(this._inorder) {
                            this._remaining -= delta;
                            break;
                        } else {
                            this.set_remain();
                        }
                    }
                }
                current_inorder() {
                    for(let child of this._children) {
                        if(child._state === STATES.FINISHED) continue;
                        return child;
                    }
                }
                current_outorder() {
                    const largestRem = {
                        step: null,
                        value: null
                    };
                    for(let child of this._children) {
                        if(child._children) {
                            child = child.current();
                        }
                        if(child._state === STATES.FINISHED) continue;
                        if(largestRem.value === null ||  child._remaining > largestRem.value) {
                            largestRem.value = child._remaining;
                            largestRem.step = child;
                            if(this._inorder) break;
                        }
                    }
                    return largestRem.step;
                }
                current() {
                    if(this._inorder) return this.current_inorder();
                    return this.current_outorder();
                }

                check_state() {
                    var newState = null;
                    for(let child of this._children) {
                        if(child.state === STATES.FINISHED) continue;
                        if(this._inorder) {
                            newState = child.state;
                            break;
                        } else {
                            if(child.state === STATES.STARTED) {
                                newState = child.state;
                            } else if (child.state === STATES.NOT_STARTED && !newState) {
                                newState = STATES.NOT_STARTED;
                            }
                        }
                    }
                    var x = newState || STATES.FINISHED;
                    if(x !== this.state) {
                        this.state = x;
                    }
                }
            }

            function loadStep(obj, parent) {
                if(obj.children) {
                    var multi = new MultiStep(parent, obj.text, obj.order);
                    for(let o of obj.children) {
                        multi.push(loadStep(o, multi));
                    }
                    return multi;
                } else {
                    return new SimpleStep(parent, obj.text, obj.duration || 0, obj.delay || 0);
                }
            }

            const TEMP = {
                text: "Some recipe",
                order: false,
                children: [
                    {text: "Cook chips", order: true, children: [
                        {text: "Put chips in", duration: 480, delay: 0},
                        {text: "Shake chips", duration: 0, delay: 0},
                        {text: "Put chips back in", duration: 480, delay: 0},
                        {text: "Dish chips", duration: 0, delay: 0}
                    ]},
                    {text: "Cook hunters chicken", order: true, children: [
                        {text: "Put chicken in", duration: 600, delay: 0},
                        {text: "Apply sauce", duration: 0, delay: 0},
                        {text: "Put chicken back in", duration: 600, delay: 0},
                        {text: "Dish chicken"}
                    ]}
                ]
            }
            const STEP = loadStep(TEMP);
            console.log(STEP);
            console.log(STEP.current());

            function stepc(delta) {
                STEP.tick(delta || 60);
                console.log(STEP, STEP.current());
            }

            /*
            var fullEndsAt = 0;
            var countTo = 0;
            var timerInterval = null;
            var started = false;
            var done = false;
            var audio = null;

            var interactable = false;
            function enableEdit(btn) {
                if(interactable) {
                    interactable = false;
                } else if(prompt("Enter word to edit:") === "swordfish") {
                    interactable = true;
                } else {
                    interactable = false;
                }
                btn.value = interactable ? "Disable Edit" : "Enable Edit";
                editRemember.style.display = interactable ? "" : "none";
            }
            function rememberEdit(cb) {
                if(cb.checked) {
                    Cookies.set("edit", "true");
                } else {
                    Cookies.remove("edit");
                }
            }

            var ALL = null;

            function pad(n, width, z) {
                z = z || '0';
                n = n + '';
                return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
            }

            function setDone() {
                endsAtElem.innerText = "";
                timeElem.innerText = "Complete!";
                document.body.style.backgroundColor = "green";
                if(audio != null) {
                    audio.pause();
                    audio = null;
                    ICONS.update("muted", false);
                }
            }

            function createTd(value, header = false, colspan = null) {
                var d = document.createElement(header ? "th" : "td");
                d.innerText = value;
                if(colspan)
                    d.colSpan = colspan;
                return d;
            }
            function createTr(header, ...values) {
                var tr = document.createElement("tr");
                for(let x of values) {
                    tr.appendChild(createTd(x, header));
                }
                return tr;
            }

            function setTable() {
                if(ALL !== null) {
                    tableElem.innerHTML = "";
                    var headerRow = createTr(true, "Step", "When", "Delta");
                    tableElem.appendChild(headerRow);

                    var last = 0;
                    for(let step of ALL) {
                        var diffLast = step.diff - last;
                        var date = new Date(parseInt(step.at));
                        tableElem.appendChild(createTr(false, step.description, `${pad(date.getHours(), 2)}:${pad(date.getMinutes(), 2)}:${pad(date.getSeconds(), 2)}; (t: ${step.diff})`, formatTime(diffLast, true)));
                        last = step.diff;
                    }
                }
            }

            function getTime(secs) {
                var negative = false;
                if(secs < 0) {
                    negative = true;
                    secs *= -1;
                }
                var hours = Math.floor(secs / 3600);
                secs -= hours * 3600;

                var minutes = Math.floor(secs / 60);
                secs -= minutes * 60;
                return [hours, minutes, secs, negative];
            }
            function formatTime(secs, full) {
                var arr = getTime(secs);
                var hours = arr[0];
                var mins = arr[1];
                var secs = arr[2];
                var negative = arr[3];
            
                if(full) {
                    var f = "";
                    if(hours > 0) {
                        f += `, ${hours}h`;
                    }
                    if(mins > 0) {
                        f += `, ${mins}m`;
                    }
                    if(secs > 0) {
                        f +=  `, ${secs}s`;
                    }
                    if(f === "")
                        return "Now.";
                    if(negative)
                        f += " ago";
                    return f.substring(2);
                } else {
                    return `${pad(hours, 2)}:${pad(mins, 2)}:${pad(secs, 2)}`;
                }
            }

            function updateTimer() {
                if(done) {
                    setDone();
                    return;
                }
                if(countTo === 0) return;
                setTable();
                var now = Date.now();
                var msDiff = countTo - now; 
                if(started) {
                    if(msDiff <= 0) {
                        timeElem.innerText = "+ " + formatTime(Math.round((msDiff * -1) / 1000)) + " +";
                    } else {
                        timeElem.innerText = formatTime(Math.round(msDiff / 1000));
                    }
                    var endsAtDiff = fullEndsAt - now;
                    if(endsAtDiff < 0) {
                        endsAtElem.innerText = "Recalculating ends at..";
                    } else {
                        endsAtElem.innerText = "All done in " + formatTime(Math.round(endsAtDiff / 1000), true);
                    }
                } else {
                    timeElem.innerText = "Click to begin";
                    return;
                }


                if(msDiff < 3000) {
                    document.body.style.backgroundColor = "red";
                    if(audio === null && started) {
                        audio = new Audio("/_/assets/alarm.mp3");
                        audio.loop = false;
                        audio.muted = false;
                        audio.play();
                    }
                    if(audio !== null) {
                        audio.loop = msDiff < -30000;
                        audio.play();
                    }
                } else if(msDiff < 25000) {
                    document.body.style.backgroundColor = "orange";
                } else {
                    document.body.style.backgroundColor = null;
                }
            }

            function handleMsg(e) {
                ICONS.update("wsClosed", false);
                const data = JSON.parse(e.data);
                console.log(data);
                if(_goingNext) {
                    _goingNext = false;
                    ICONS.update("sentnext", false);
                }
                if(data.done) {
                    done = true;
                    clearInterval(timerInterval);
                    timerInterval = null;
                    document.body.removeEventListener("click", handleNext);
                    setDone();
                } else {
                    if(audio) {
                        audio.pause();
                        audio = null;
                        ICONS.update("muted", false);
                    }
                    const current = data.current;
                    descElem.innerText = current.description;
                    countTo = parseInt(current.at);
                    timerInterval = setInterval(updateTimer, 50);
                    console.log(data, data.started, !!data.started);
                    started = !!data.started;
                    fullEndsAt = parseInt(data.end ?? 0);
                    var msDiff = fullEndsAt - Date.now();
                    if(msDiff < 0) {
                        endsAtElem.innerText = "Recalculating ends at..";
                    } else {
                        endsAtElem.innerText = "All done in " + formatTime(Math.round(msDiff / 1000), true);
                    }

                    if(data.next) {
                        afterElem.innerText = `Next: ${data.next.description}`;
                    }
                    ALL = data.steps;
                    setTable();
                }
            }

            function onWsClose(e) {
                ICONS.update("wsClosed", true);
            }

            _goingNext = false;
            function moveNext() {
                if(!interactable) {
                    console.log("Attempted to advance but we're not in edit mode.")
                    return;
                }
                started = true;
                if(_goingNext === false) {
                    _goingNext = true;
                    ICONS.update("sentnext", true);
                    WSC.socket.send(JSON.stringify({"data": "next"}));
                }
            }

            function handleNext(ev) {
                console.log(ev.target);
                if(ev.target.tagName === "INPUT") return;
                moveNext();
            }
            function onKeyUp(ev) {
                console.log(ev);
                if(ev.code === "Space") {
                    moveNext();
                    ev.preventDefault();
                } else if(ev.code === "Enter") {
                    if(audio) {
                        if(audio.muted) {
                            moveNext();
                        } else {
                            audio.muted = true;
                            ICONS.update("muted", true);
                        }
                    }
                    ev.preventDefault();
                }
            }
            function init() {
                descElem.innerText = "...";
                timeElem.innerText = "??:??:??";
                WSC.initWS(`food?id=${ID}`, 5, handleMsg, onWsClose, function(e) {
                    // reconnect limit reached
                    window.location.reload();
                });
                document.body.addEventListener("click", handleNext, true);
                document.body.addEventListener("keyup", onKeyUp, true);

                if(Cookies.get("edit")) {
                    editRemember.checked = true;
                    interactable = true;
                    editBtn.value = "Stop editing";
                } else {
                    editRemember.style.display = "none";
                }
            }
            init();*/
        </script>
    </body>
</html>